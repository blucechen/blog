## 计算机整数存储
https://www.cnblogs.com/despatch/p/10832980.html 【原码、补码、反码】
1. 机器数   
    一个数在计算机中以二进制的形式表示，叫做这个数的机器数；机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1（最高位为符号位）
    比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。

2. 真值   
    10000011形式值:131   真值:-3
    0000 0001的真值 = +000 0001 = +1


1. 原码   
    符号位+真值的绝对值 假定用8位二进制表示 则： 3 -> [0000 0011]  -3 -> [1000 0011] 
    用最高为表示符号位
    8位二进制原码表示的取值范围：[1111 1111 , 0111 1111]  ->  [-127，127]

2. 反码   
    1.符号位不变 1.1 正数是其本身  1.2 负数是其各位取反(符号位取反)
    [+1] = [00000001]原 = [00000001]反
    [-1] = [10000001]原 = [11111110]反

3. 补码 - 让符号位也参与计算   
    1.符号位不变  1.1 正数是其本身  1.2 负数是反码+1
    [+1] = [00000001]原 = [00000001]反 = [00000001]补
    [-1] = [10000001]原 = [11111110]反 = [11111111]补

    (-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补
    -1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 
    所以-128并没有原码和反码表示.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的)

    使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 
    这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127]


    题目：
    给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。

    如果反转后整数超过 32 位的有符号整数的范围 [−2(31次方),  2(31次方) − 1] ，就返回 0。

    假设环境不允许存储 64 位整数（有符号或无符号）。

    提示： -2(31次方) <= x <= 2(31次方) - 1
