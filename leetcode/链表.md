# 链表
## 141环形链表
Q：为什么只能是快指针移动两步，慢指针移动一步？   
A: 这样可以保证加入环存在，快慢指针一定会相遇。
```ts
A -> B - > C -> D - > C
加入上面一个链表，有一个环，D指向C， C指向D

某一时刻： 慢指针指向D， 快指针指向C
如果快指针一次走三步，慢指针一次走一步;
下一时刻： 快 D ； 慢 C
再下一时刻： 快 C ; 慢 D
快慢指针将不会相遇
```

## 142环形链表2
### 思路分析
思路来源： [leetcode](https://leetcode.cn/problems/linked-list-cycle-ii/solution/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/)  
思路解析：需要进行一定的数学分析
约定名称： head 到 `环的起点(不含)` 设为 a; 环的长度 设为 b;
1. 快指针走过的长度为f, 慢指针走过的长度为s，快指针一次走两步，慢指针一次走一步
2. 当一个指针走过 a + nb的时候，其一定位于入环的第一个节点
3. 当快慢指针相遇时 f = 2s; 同时 f - s = nb 即 f = s + nb; 同时 s = nb
4. 结合2、3 可得知，只要在快慢指针相遇时，慢指针再走 a 步，即可到达`环的起点`，那么如何得知a步是多少呢？
5. 如果有一个指针x从head处出发，一次走一步，走a步就到了 `环的起点`； 此时 慢指针往前走a步也到了 `环的起点`；此时 慢指针与指针x相遇在 `环的起点`

### 发现的问题
```ts
function detectCycle(head: ListNode | null): ListNode | null {
    if (null === head || null === head.next) return null
    let fast = head.next
    let slow = head
    while (fast !== slow) {
        // 并不相等
        if (null === fast || null === fast.next) return null
        slow = slow.next
        fast = fast.next.next
    }
    fast = head
    while (fast !== slow) {
        fast = fast.next
        slow = slow.next
    }
    return slow
}
```
上面的代码会有什么问题， 第二个while会走不出循环造成死循环  
原因在于 没有理解`思路分析`的第三点，需要保证`f = 2s`，上面的代码初始值设置了`let slow = head； let fast = head.next` 会导致`f`比`s`多走一步，因为两者并没有从同一起点出发（`f = 2s + 1`），所以为了保证从同一起点出发，在找到环以后，需要让 `s` 前进一步： `slow = slow.next`  
所以你会发现网上的答案都是`s` `f`都是从 `head` 出发进行是否有环的判断，这样就可以避免上面的需要额外补上`slow = slow.next`的逻辑
```ts
function detectCycle(head: ListNode | null): ListNode | null {
    if (null === head || null === head.next) return null
    let fast = head.next
    let slow = head
    while (fast !== slow) {
        // 并不相等
        if (null === fast || null === fast.next) return null
        slow = slow.next
        fast = fast.next.next
    }
    slow = slow.next
    fast = head
    while (fast !== slow) {
        fast = fast.next
        slow = slow.next
    }
    return slow
}
// or
function detectCycle(head: ListNode | null): ListNode | null {
    if (null === head || null === head.next) return null
    let fast = head
    let slow = head
    while (null !== fast && null !== fast.next) {
        slow = slow.next
        fast = fast.next.next
        if (fast === slow) break
    }
    if (fast !== slow) return null// 上面的while可能由于null !== fast && null !== fast.next不满足或者fast === slow 退出，所以需要做判断
    fast = head
    while (fast !== slow) {
        fast = fast.next
        slow = slow.next
    }
    return slow
}
```

## 相交链表
思路：如果两个链表l、s的长度一致，且相交，那么都从头部出发，两者走到相交点的步数是一样的  
那么如何让长链表前面先多走(l - s)步，然后短链表再出发呢？
> leetcode 神评论： ‘走到尽头见不到你，于是走过你来时的路，等到相遇时才发现，你也走过我来时的路。’[链接](https://leetcode.cn/problems/intersection-of-two-linked-lists/solution/tu-jie-xiang-jiao-lian-biao-by-user7208t/)
